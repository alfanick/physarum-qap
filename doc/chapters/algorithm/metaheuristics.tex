\section{Physarum-based Metaheuristic}
\label{section:algorithm_metaheuristic}

Emboldened by the experience with the physarum machine, we thought of making it more practical. We thought of simulating \textit{Physarum Polycephalum}, hoping for lowering execution time for the naive algorithm. Instead we propose a new algorithm designed from the ground up, which is inspired by observed behaviour of the slime mould. While the algorithm was created for solving Quadratic Assignment Problem, it is an universal metaheuristic which can be applied to number of optimization problems.


\subsection{Algorithm overview}

The algorithm can be divided in three distinct phases: exploration, crawling and merging. These phases are executed sequentially in a loop, until stop condition is satisfied. General overview of the algorithm can be seen in pseudocode \ref{algorithm:m_general}. 

\begin{algorithm}[H]
  \KwData{optimization problem with neighbourhood definition}
  \KwResult{approximated result}
  \BlankLine

  environment $\leftarrow$ initialize\_environment(problem)\;
  colony $\leftarrow$ initialize\_colony(environment)\;

  \Repeat{$colony.stable \lor {\neg}experiment.next$}{
    \For{$plasmodium \in colony$}{
      plasmodium.explore()\;
      plasmodium.crawl()\;
    }
    colony.merge()\;
  }

  \Return{colony.largest}\;

  \caption{Overview of physarum-based metaheuristic}
  \label{algorithm:m_general}
\end{algorithm}

Initialization of environment includes sampling of solutions space: $k$ random assignments are taken, for each of them a cost is computed (pseudocode \ref{algorithm:m_env_initialization}). An assignment with the smallest cost is saved as exemplar for further calibration. Colony of "virtual physarum" is put on best $l$ out $k$ samples (pseudocode \ref{algorithm:m_colony_initialization}).

\begin{algorithm}
  \KwData{optimization problem}
  \KwResult{list of samples}
  \BlankLine

  solutions $\leftarrow$ \{\}\;
  \For{$i \leftarrow 0$ \KwTo $k$}{
    solutions $\leftarrow$ solutions $\cup$ \{random\_solution()\}\;
  }

  sorted\_solutions $\leftarrow$ sort(solutions, problem.cost)\;
  environment.best\_cost $\leftarrow$ problem.cost(sorted\_solutions.first)\;
  
  \Return{sorted\_solutions}\;

  \caption{Initialization of environment}
  \label{algorithm:m_env_initialization}
\end{algorithm}

\begin{algorithm}
  \KwData{environment with sampled solutions}
  \KwResult{set of virtual physarum}
  \BlankLine

  colony $\leftarrow$ \{\}\;
  \For{$i \leftarrow 0$ \KwTo $l$}{
    plasmodium $\leftarrow$ create\_plasmodium(environment.samples[i])\;
    colony $\leftarrow$ colony $\cup$ \{plasmodium\}\;
  }
  \Return{colony}\;

  \caption{Initialization of colony}
  \label{algorithm:m_colony_initialization}
\end{algorithm}

Simulation stops when plasmodia crawl no more (are in a stable state) or given number of iterations or time has been exceeded. Result of optimization can be obtained as the solution with the smallest cost which is occupied by a virtual physarum at the end of simulation.


\subsection{Environment}

The naive algorithm assumed uniform distribution of food sources which are inversely proportional to the cost of solution, however there is no such need in our metaheuristic solution. In similar manner solutions are represented as vierual food sources, but they are generated dynamically --- virtual food consume no memory unless they are visited by plasmodium. "Nutritional energy" is calculated dynamically when a food is visited as follows: 

% TODO maybe just frac squared???
\begin{equation}
  E_{solution} = a \cdot q^{\frac{calibrated\_cost}{cost(solution)}} + {\Delta}E_{solution}
\end{equation}

Where $calibrated_cost$ is cost of minimal solution obtained via initial sampling process, $a > 0$ is scaling factor, $q > 1$ is exponentiation base. ${\Delta}E_{solution}$ is already consumed energy from given $solution$. At the start each ${\Delta}E_{solution}$ is equal $0$, so there is no need of storing such information, but as plasmodium explores and crawls ${\Delta}E_{solution}$ is updated, taking at most $O(n!)$ memory if every solution would be explored.

The algorithm defines neighbourhood for Quadratic Assignment Problem as single pair swap, giving $\frac{n\cdot(n-1)}{2}$ possible neighbours for each assignment. However, instead of deterministc generation of the neighbourhood, a stochastic one is used --- the neighbour solution is created by swapping two random positions from given assignment.

Within this environment lives a colony of virtual plasmodia --- $l$ different plasmodia are placed on different food sources selected from initial sampling (pseudocode \ref{algorithm:m_colony_initialization}). 

\subsection{Virtual plasmodium}

A plasmodium is an active state of \textit{Physarum Polycephalum}, in laboratory it moves on an agar substrate foraging for food, usually the oatmeal. It feeds by covering multiple food sources with its body and transfers nutrients to its distant parts.

Virtual plasmodium is modelled after biological one: it feeds on virtual food, which provides energy required for further exploration and movement. Energy is essential for keeping the plasmodium active --- most of it is used for exploration phase, while the rest is used for actual movement to the other food sources. Each virtual plasmodium is created with some initial energy $E_{initial}$ motivating initial exploration (changing ${\Delta}E_{plasmodium}$). After exploration it can crawl to some of explored food sources and exploit every source of energy it remains on --- the plasmodium has that much energy as much food is available under its body (plus some extra initial energy):

\begin{equation}
  E_{plasmodium} = E_{initial} + {\Delta}E_{plasmodium} + \sum\limits_{solution \in plasmodium} E_{solution}
\end{equation}

If no energy is left ($E_{plasmodium}$ is equal zero), the plasmodium is considered dead.


\subsubsection{Exploration phase}

The exploration phase looks through neighbourhood in so new food sources can be found (pseudocode \ref{algorithm:m_exploration}). For every already occupied food source, a neighbour is generated by swapping two randomly choosen assignments. Such neighbour solution is added to a frontier, which is an analogy to slime mould's head. Each visit consumes parametrized $E_{explore}$ energy. This phase is repeated as long as there is enough energy left for crawling to another solution $E_{crawl}$.

Exploration consumes $E_{initial}$ energy, when none is left, energy from the food sources is used, effectively decreasing $E_{solution}$ available within the environment.

\begin{algorithm}
  \KwData{plasmodium placed within environment}
  \KwResult{solutions frontier}
  \BlankLine

  frontier $\leftarrow$ \{\}\;
  \Repeat{$E_{crawl} \geq E_{plasmodium}$}{
    \For{$solution \in plasmodium$}{
      next\_solution $\leftarrow$ environment.neighbour(solution)\;
      frontier $\leftarrow$ frontier $\cup$ \{next\_solution\}\;

      \uIf{$E_{initial} \geq |{\Delta}E_{plasmodium}| + E_{explore}$}{
        ${\Delta}E_{plasmodium} \leftarrow {\Delta}E_{plasmodium} - E_{explore}$\;
      }
      \Else{
        ${\Delta}E_{solution} \leftarrow {\Delta}E_{solution} - E_{explore}$\;
      }
    }
  }

  \Return{frontier}\;

  \caption{Plasmodial exploration phase}
  \label{algorithm:m_exploration}
\end{algorithm}

The exploration phase simply selects candidate solutions (frontier) for further optimization. Physarum can occupy many food sources, representing this way a trail of previously tested solutions --- when choosing a neighbour it tries to avoid suspensing in a local minimum as it can explore historic neighbourhoods.

\subsubsection{Crawling phase}
% TODO crawl phase


\subsubsection{Merging plasmodia}
% TODO merge phase


\subsection{Available parameters}
% TODO illustrative example


\subsection{Illustrative operation}
% TODO parameters tuning

